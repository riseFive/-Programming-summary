## mysql 逻辑架构
### 1.逻辑架构图
![](http://orvwtnort.bkt.clouddn.com/201721343/1522653458851.png)

### 2.并发控制
#### 2.1 读与锁
共享锁和排他锁，也就是读锁和写锁。写锁比读锁有更高的优先级
>注意：一个写锁请求可能会被插入到读锁队列的前面
####2.2 锁粒度
>因为锁的各种操作，包括获得锁、检查锁是否解除、释放锁等。都会增加系统的开销。如果系统花费大量的时间来管理锁，而不是存取数据，那么对系统的性能也会带来问题。为了解决这个问题，mysql实现锁粒度的选择，每种mysql存储引擎都可以实现自己的锁策略和锁粒度。让锁固定在某个级别，从而在锁的开销和数据安全性之间寻得平衡。
#####2.2.1表锁
- 表锁是mysql最基本的锁策略，并且是开销最小的策略。
- 服务器会为诸如`alter table`之类的语句使用表锁，而忽略存储引擎的锁机制。
#####2.2.1行级锁
- 行级锁可以最大程度支持并发处理，但同时带来了最大的锁开销。
- 行级锁只在存储引擎层实现，而`mysql`服务层没有实现(看上图)。

###3.事务
>事务就是一组原子性的`sql`查询，要么全部执行成功，要么全部失败
#### 3.1 ACID
**A:原子性(atomicity)**
 >一个事务必须被视为一个不可分割的最小单位，要么全部提交成功，要么全部回滚 
 
**C:一致性(consistency)**
>数据库总是从一个一致性状态转换到另外一个一致性状态。

**I:隔离性(isolation)**
> 通常来说，一个事务所做的修改在最终提交以前，对其他事务不可见。(只是通常来说，这个要和隔离级别联合起来了解)

**D:持久性(durability)**
>一旦事务提交，修改就永久保存到数据库中。

####3.2 隔离级别
#####3.2.1 未提交读(read uncommitted)
> 在这个级别中，事务中的修改，即使没有提交，对其他事务都是可见的。事务可以读取未提交的数据，这也被称为脏读(`dirty read`)。在实际使用中，很少使用
#####3.2.2 提交读(read committed)
>一个事务开始时，只能看见已经提交的事务所做的修改。也就是说：一个事务从开始知道提交之前，所做的任何修改对其他事务都是不可见的。这个级别也叫`不可重复读`。因为两次执行同样的查询，可能会得到不一样的结果
#####3.2.3 可重复读(repeatable read)
>这个级别解决了脏读的问题。保证了在同一个事务中多长读取同样记录的结果是一致的。但是还有没有解决`幻读`问题。所谓`幻读`，就是当某个事务在读取摸个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围内的记录时，会产生幻行。InnoDB通过多版本并发控制(MVCC)来解决幻读的问题。

>可重复读是mysql默认的事务隔离级别

#####3.2.4 可串行化(serializable)
>很少用，这个级别会在读取的每一行数据上都加上锁，所以可能导致大量的超时和锁竞争问题
![](http://orvwtnort.bkt.clouddn.com/201721343/1522657447820.png)

修改隔离级别：
```mysql
SET SESSION  TRANSACTION ISOLATION LEVEL  READ COMMITTED ;
```
### 4.死锁
死锁是指多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环得现象。InnDB目前处理死锁的方法是将持有最少行级排他锁的事务进行回滚

###5.多版本并发控制(mvcc)
InnDB的mvcc,是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间(或删除时间)。当然存储的并不是实际的时间值，而是系统版本好。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

举个例子，在`可重复读`级别下，mvcc的操作：
select 
innoDB会根据以下两个条件检查每行的记录：
    a.只查找版本早于当前事务版本的数据行，也就是说，行的系统版本号小于或等于事务的系统版本号，这样可以确保事务读取的行，要么是在事务开始前就已经存在的，要么是事务自身插入或者修改过的。
    b.行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除
 
insert
  innoDB 为新插入的每一行保存当前系统版本号作为行版本号

delete
  innoDB 为删除的每一行保存当前系统版本号作为行删除标识

update
  innoDB 为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识
  
  mvcc 只在`提交读`和`可重复读`两个级别下工作。
  

  ###6.mysql的存储引擎
  
 在文件系统中，mysql将每个数据库(也可称之为schema)保存为数据目录下的一个子目录。创建表时，mysql会在数据库子目录下创建一个和表同名的.frm文件保存表的定义
    
  显示表的相关信息：
  ```mysql
 SHOW TABLE STATUS LIKE 'user'
```
#####6.1 innodb引擎简介
innodb 采用mvcc来支持高并发，并且实现了四个标准的隔离级别。默认级别是"可重复读"，并且通过间隙锁(next-key locking)策略防止幻读的出现。间隙锁使得innodb不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定。以防止幻影行的插入
innodb基于聚簇索引建立。聚簇索引对主键查询有很高的性能。不过他的二级索引中必须包含主键列，如果主键列很大的话，其他的索引都会很大。
#####6.2 mysql引擎简介
myisam 不支持事务和行级锁，崩溃后无法完全恢复。
myisam 支持全文索引
myisam 会将表存储在两个文件中：数据文件和索引文件，分别以`.MYD`和`.MYI`为扩展名。

### 转换表的引擎
1.alter table
```mysql
ALTER TABLE mytable ENGINE =InnoDB;
```
主要：需要执行很长时间。mysql会按照将数据从原表复制到一张新的表中，在复制期间可能会消耗系统所有的I/能力O.同时对原表会加上读锁

2.导出与导入
使用 mysqldump 

3.创建和查询
```mysql
CREATE  TABLE innodb_table LIKE myisam_table;
ALTER TABLE  innodb_table ENGINE =InnoDB;
INSERT INTO innodb_table select * FROM myisam_table;
```
数据量不大的话，可以这样。如果数据量太大，可以考虑分批处理,主键字段为id:
```mysql
> START TRANSACTION;
> INSERT INTO innodb_table select * from myisam_table where id BETWEEN x and y;
>COMMIT ;
```