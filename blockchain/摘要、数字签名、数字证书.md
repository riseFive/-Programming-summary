摘要
--
一段信息，经过摘要算法得到一串哈希值，就是摘要(dijest)。

信息是任意长度，而摘要是定长。

摘要算法有MD5、SHA1、SHA256、SHA512等，算法把无限的映射成有限，因此可能会有碰撞（两个不同的信息，算出的摘要相同）

摘要不同于加密算法，因为不存在解密，只不过从摘要反推原信息很难（可以认为能加密但无法解密还原，但可以用于比对）。类比到人的话：时间一直向前走 ，我没有办法从现在的你身上反观到你过去的样子，也没法从现在的他身上反观到他过去的样子……但你们现在的样子依然有作用，那就是在于“是否相同”：我可以通过比对现在的你和现在的他是否相同，来判断过去的你和他是否相同，而无需知道过去的你和过去的他具体是什么样子。

摘要相同，信息一定相同。如果两张图片的md5相同，说明图片完全一样，不需要重复爬取。

利用这个特点，摘要还可以用于应用在网站后台数据库中，用于比对用户的输入密码和预设密码是否相同。这里都无需关心密码本身是什么，关注的是密码是否相同，而密码是否相同取决于摘要是否相同，所以问题转化成了摘要是否相同。将用户密码的摘要而不是密码本身保存在数据库中，因为反推很难，所以真实密码是保密的……非要暴露的话，也是通过比对而不是反推。

非对称加密算法
-
算法重要的概念是公钥和私匙。

先有私钥，再用函数生成公钥。公钥包含了私钥的信息，但也掺杂了其他随机变量，因此不能反推。

私匙不要泄露，公钥要告诉和你通信的对方。公钥加密，只有对应私钥能解开（保密）；私钥加密，只有对应公钥能解开（不可抵赖）。

具体有两种情形：

（1）对方用你的公钥加密信息，你收到后用私钥解开。

只有你有私钥，所以只有你能解开，换句话说，有私钥才能看到信息，很安全。

（2）你拿私钥加密信息，对方收到后用你的公钥解开。

公钥是公开的，所以其他人也可以看到你的信息，不保密。

私钥加密，只有对应公钥能解开。既然用你的公钥能解开，说明加密一定是你的私钥。私钥只有你有，所以一定是你发送的，你不可抵赖。

数字签名
-
**摘要经过加密，就得到数字签名**

数字签名在发送方，分两步：（1）从内容算摘要（哈希算法）（2）从摘要明文到摘要密文，也称数字签名（发送方私钥+加密算法）

数字签名验证在接收方，分两步：（1）从摘要密文（数字签名）到摘要明文（发送方公钥+解密算法）（2）从收到的内容当场计算摘要（哈希算法），与（1）的结果比对是否一致



如果一致，可以说明两点：

（1）内容未被篡改（摘要一致）

（2）内容只能是私钥拥方发送，不可抵赖（密文能够用对方的公钥解开）



然后单独想一下，

（1）为什么要对摘要加密后再发送？为什么不直接发摘要？摘要不可以逆向推导原文，摘要泄露了也没事……

答：摘要泄露是没事，但不怀好意的人的目的可能并不在想要窃听你发送了什么，而是想伪造发送的内容让你相信。通过同时替换摘要和内容，很简单就实现了。所以摘要需要经过加密，不怀好意的人没有私钥，就无法用到加密算法。

（2）为什么不直接对内容加密，而是先生成摘要，对摘要加密？

答：可能是内容很长吧，直接加密算半天！摘要算法可以把无限长的内容输出成长度固定的摘要，再进行加密时间就是可以预估的

数字证书
--
上面的一切都很完美，你用公钥能够解密，说明确实是私钥方发送的，你很放心……

但有没有想过，万一这把公钥本身，就被人做了手脚？？？

为了保证“公钥”是可信的，数字证书应运而生。

数字证书里有个重要概念，CA,发送方先把自己的公钥给CA，CA对其进行加密得到加密后的发送方公钥（用的是CA的私钥和CA加密算法），也就是CA的数字证书。

注意这里有两个不同的非对称算法（对应2个公钥私钥对），一个算法是发送方加密摘要的，用于生成数字签名；另一个算法是CA加密发送方公钥的，用于生成数字证书。两个算法相互独立，没有必然联系。

发送时不仅发送内容、数字签名，还包含发送方的数字证书。接收方拿到后，首先从数字证书中解密出发送方公钥（用的是CA的公钥和CA解密算法），这个公钥必然是可信的。然后就是和前面一样的流程，拿发送方公钥去解密数字证书，得到摘要；最后比对摘要是否一致。



一个问题：既然数字证书是为了保证发送方公钥不是别人伪造的，那怎么保证“CA”的公钥不是伪造的呢？

答：CA是第三方机构，CA公钥是公开的，接收方可以跟别人比对（比如在网上查询），因此不可能伪造。但是发送方公钥，接收方是通过通信得到的，收到后无法验证。

扩展阅读
--
[数字签名是什么](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html?from=singlemessage)